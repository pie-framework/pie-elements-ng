# IIFE Bundle Architecture: How PIE Elements Are Bundled

**Date:** 2026-01-31
**Systems:** pie-shared-lib-builder + pie-api-aws bundler

## Overview

PIE uses a sophisticated **shared library architecture** to minimize bundle duplication. The system has two key components:

1. **pie-shared-lib-builder** (`@pslb/pslb`) - Creates shared library bundles
2. **pie-api-aws bundler** - Creates element IIFE bundles that reference shared libs

## The Problem Being Solved

### Without Shared Libraries (Naive Approach)

```
multiple-choice.js  (~3MB)
â”œâ”€â”€ React (500KB)
â”œâ”€â”€ @mui/material (800KB)
â”œâ”€â”€ @pie-lib/math-rendering (2.7MB)  â† Duplicated!
â””â”€â”€ element code (50KB)

drag-in-the-blank.js (~3MB)
â”œâ”€â”€ React (500KB)
â”œâ”€â”€ @mui/material (800KB)
â”œâ”€â”€ @pie-lib/math-rendering (2.7MB)  â† Duplicated!
â””â”€â”€ element code (60KB)

Total: ~6MB (with massive duplication)
```

### With Shared Libraries (PIE Approach)

```
Shared Libraries (loaded once):
  @pie-lib/math-rendering-module.js (~2.7MB)
  @pie-lib/pie-toolbox-module.js (~1.5MB)

Element Bundles (reference shared libs):
  multiple-choice.js (~200KB)
  drag-in-the-blank.js (~250KB)

Total: ~4.7MB (21% smaller, and libs cached!)
```

---

## Part 1: Shared Library Builder (@pslb/pslb)

**Location:** `kds/pie-shared-lib-builder`

### Purpose

Creates **shared library bundles** with manifests that describe their contents.

### How It Works

#### Step 1: Build Shared Library

```bash
cd pie-lib/packages/math-rendering
pslb build
```

#### Step 2: Generate manifest.json

```json
{
  "name": "@pie-lib/math-rendering-module",
  "version": "1.0.16",
  "mappings": {
    "@pie-lib/math-rendering": "_dll_pie_lib__math_rendering"
  },
  "versionInfo": {
    "data": {
      "@pie-lib/math-rendering": {
        "version": "2.3.11"
      }
    },
    "hash": "f7881b43b95f70a6c22b3183c73215226c57ac21"
  }
}
```

**Key fields:**

- `mappings`: Package name â†’ internal module name
- `versionInfo`: Tracks what's bundled
- `hash`: Content hash for cache busting

#### Step 3: Create DLL Bundle

The builder uses **Webpack DLL Plugin** to create:

```javascript
// @pie-lib/math-rendering-module/index.js (simplified)
var _dll_pie_lib__math_rendering = (function() {
  // ... full MathJax code here (~2.7MB)
  return {
    renderMath: function(...) { ... },
    wrapMath: function(...) { ... },
    unWrapMath: function(...) { ... },
    mmlToLatex: function(...) { ... }
  };
})();

// Export to global scope
window['_dll_pie_lib__math_rendering'] = _dll_pie_lib__math_rendering;
```

### Publish to NPM

```bash
pslb build --publishLibs --token=<npm-token>
```

This publishes:

- `@pie-lib/math-rendering-module@1.0.16` to NPM
- Contains: `index.js` + `manifest.json`

---

## Part 2: Element Bundle Builder (pie-api-aws)

**Location:** `kds/pie-api-aws/packages/bundler`

### Purpose

Creates **element IIFE bundles** that reference shared libraries instead of bundling them.

### Key Files

```
packages/bundler/src/
â”œâ”€â”€ bundlers/
â”‚   â””â”€â”€ player.ts          # Orchestrates bundling
â”œâ”€â”€ webpack/
â”‚   â””â”€â”€ player.ts          # Webpack config for IIFE
â”œâ”€â”€ code-generator.ts      # Generates entry files
â””â”€â”€ dependency.ts          # Resolves dependencies
```

### How It Works

#### Step 1: Analyze Dependencies

```typescript
// Input: Element dependencies
const deps = [
  { name: '@pie-element/multiple-choice', version: '12.0.0' }
];

// Read package.json
{
  "name": "@pie-element/multiple-choice",
  "dependencies": {
    "@pie-lib/math-rendering": "4.1.0-next.4",  // â† Will be externalized
    "@pie-lib/render-ui": "5.1.0-next.5",
    "react": "18.2.0"
  }
}
```

#### Step 2: Generate Entry Files

**Code:** `bundlers/player.ts:generateJsFile()`

Generates three entry points:

**`player.js`** (student view):

```javascript
// Generated by code-generator.ts
import MultipleChoice from "@pie-element/multiple-choice";

export default {
  "@pie-element/multiple-choice": {
    Element: MultipleChoice,
  },
  "@pie-element/multiple-choice@12.0.0": {
    Element: MultipleChoice,
  },
};
```

**`client-player.js`** (includes controller):

```javascript
import MultipleChoice from "@pie-element/multiple-choice";
import * as Controller from "@pie-element/multiple-choice/controller";

export default {
  "@pie-element/multiple-choice": {
    Element: MultipleChoice,
    controller: Controller,
  },
};
```

**`editor.js`** (includes configure + controller):

```javascript
import MultipleChoice from "@pie-element/multiple-choice";
import Configure from "@pie-element/multiple-choice/configure";
import * as Controller from "@pie-element/multiple-choice/controller";

export default {
  "@pie-element/multiple-choice": {
    Element: MultipleChoice,
    Configure: Configure,
    controller: Controller,
  },
};
```

#### Step 3: Configure Webpack

**Code:** `webpack/player.ts`

**Key configuration:**

```typescript
const BUNDLE_LIB_PACKAGES = ["@pie-lib/pie-toolbox", "@pie-lib/math-rendering"];

const config = {
  // Externalize shared libraries
  externals: {
    "@pie-lib/math-rendering": "@pie-lib/math-rendering",
    "@pie-lib/pie-toolbox": "@pie-lib/pie-toolbox",
  },

  // Output as IIFE attached to window
  output: {
    library: "pie",
    libraryTarget: "window",
    filename: "[name].js",
  },

  // Plugin to resolve per-element versions
  plugins: [
    new NormalModuleReplacementPlugin(
      /@pie-lib\/(math-rendering|pie-toolbox)/,
      (resource) => {
        // Replace with element-specific version
        // e.g., '@pie-lib/math-rendering-multiple-choice'
      },
    ),
  ],
};
```

#### Step 4: Build IIFE Bundle

**Webpack process:**

```
Entry: player.js
  â†“
Resolve imports:
  @pie-element/multiple-choice â†’ bundle it
  @pie-lib/math-rendering â†’ EXTERNAL (don't bundle)
  â†“
Generate IIFE:
  var pie = (function() {
    // Element code here
    // References to @pie-lib/math-rendering remain as globals
  })();
  â†“
Output: player.js (~200KB)
```

**Generated bundle structure:**

```javascript
// player.js (simplified)
var pie = (function () {
  "use strict";

  // External reference (not bundled)
  var mathRendering = window["_dll_pie_lib__math_rendering"];

  // Element code
  var MultipleChoice = function (props) {
    // Uses mathRendering.renderMath()
    mathRendering.renderMath(element);
    // ...
  };

  return {
    "@pie-element/multiple-choice": {
      Element: MultipleChoice,
    },
  };
})();

// Attach to window
window.pie = pie;
```

---

## Part 3: Runtime Loading

### Browser Load Sequence

```html
<!-- 1. Load shared libraries first -->
<script src="https://cdn.example.com/@pie-lib/math-rendering-module@1.0.16/index.js"></script>
<script src="https://cdn.example.com/@pie-lib/pie-toolbox-module@2.0.5/index.js"></script>

<!-- 2. Load element bundle -->
<script src="https://cdn.example.com/bundles/multiple-choice@12.0.0/player.js"></script>

<!-- 3. Element can now use shared libs -->
<script>
  // pie.['@pie-element/multiple-choice'].Element is available
  // It references window['_dll_pie_lib__math_rendering']
</script>
```

### How Elements Find Shared Libraries

**In element source:**

```javascript
import { renderMath } from "@pie-lib/math-rendering";
```

**After webpack externalization:**

```javascript
// Runtime: looks for window['_dll_pie_lib__math_rendering']
const mathRendering = window["_dll_pie_lib__math_rendering"];
const { renderMath } = mathRendering;
```

---

## Math Rendering in IIFE Bundles

### Current Approach (MathJax v3 in Shared Library)

**Shared library:**

```
@pie-lib/math-rendering-module@1.0.16
â”œâ”€â”€ index.js (~2.7MB)
â”‚   â””â”€â”€ Contains: mathjax-full, lodash, debug, etc.
â””â”€â”€ manifest.json
```

**Element bundle:**

```javascript
// multiple-choice player.js
import { renderMath } from "@pie-lib/math-rendering"; // â† External

// Webpack makes this:
const mathRendering = window["_dll_pie_lib__math_rendering"];
mathRendering.renderMath(element);
```

**Bundle sizes:**

- Shared lib: ~2.7MB (loaded once, cached)
- Element: ~200KB (no math-rendering code)
- Total first load: ~2.9MB
- Total subsequent elements: ~200KB each (lib cached!)

### Why Externalization Works

**Without externalization (every element bundles it):**

```
Element 1: 200KB + 2.7MB = 2.9MB
Element 2: 250KB + 2.7MB = 2.95MB
Element 3: 180KB + 2.7MB = 2.88MB
Total: ~8.7MB
```

**With externalization (shared library):**

```
Shared lib: 2.7MB (once)
Element 1: 200KB
Element 2: 250KB
Element 3: 180KB
Total: ~3.3MB (62% smaller!)
```

---

## Per-Element Library Versions

### The Version Resolution Problem

Different elements may depend on different versions:

```
multiple-choice depends on @pie-lib/math-rendering@4.0.0
drag-in-the-blank depends on @pie-lib/math-rendering@4.1.0
```

### Solution: NormalModuleReplacementPlugin

**Code:** `webpack/player.ts:111-141`

```typescript
new NormalModuleReplacementPlugin(
  /@pie-lib\/(math-rendering|pie-toolbox)/,
  (resource) => {
    const element = elements.find((el) => resource.context.includes(el));
    const libPackage = "@pie-lib/math-rendering";

    // Determine which version this element needs
    if (element) {
      // Use element-specific alias
      // e.g., '@pie-lib/math-rendering-multiple-choice'
      replacement = `${libPackage}-${element}`;
    } else {
      // Use default version
      replacement = `${libPackage}-root`;
    }

    // Rewrite the import
    resource.request = resource.request.replace(libPackage, replacement);
  },
);
```

### Webpack Alias Mapping

```typescript
resolve: {
  alias: {
    '@pie-lib/math-rendering-root': '/path/to/math-rendering@4.0.0',
    '@pie-lib/math-rendering-multiple-choice': '/path/to/math-rendering@4.0.0',
    '@pie-lib/math-rendering-drag-in-the-blank': '/path/to/math-rendering@4.1.0'
  }
}
```

Each element gets the correct version bundled as an external reference.

---

## CDN Deployment

### Bundle Structure on CDN

```
https://proxy.pie-api.com/bundles/
â”œâ”€â”€ @pie-lib/
â”‚   â”œâ”€â”€ math-rendering-module@1.0.16/
â”‚   â”‚   â”œâ”€â”€ index.js (2.7MB)
â”‚   â”‚   â””â”€â”€ manifest.json
â”‚   â””â”€â”€ pie-toolbox-module@2.0.5/
â”‚       â”œâ”€â”€ index.js (1.5MB)
â”‚       â””â”€â”€ manifest.json
â””â”€â”€ @pie-element/
    â”œâ”€â”€ multiple-choice@12.0.0/
    â”‚   â”œâ”€â”€ player.js (200KB)
    â”‚   â”œâ”€â”€ client-player.js (250KB)
    â”‚   â””â”€â”€ editor.js (300KB)
    â””â”€â”€ drag-in-the-blank@11.5.0/
        â”œâ”€â”€ player.js (220KB)
        â””â”€â”€ ...
```

### Load Pattern

```javascript
// PIE Player loads:
1. Analyze item config
2. Determine required elements
3. Load shared libraries (if not cached)
4. Load element bundles
5. Instantiate elements
```

---

## Comparison: IIFE vs ESM Modules

| Aspect           | IIFE (Current)          | ESM (pie-elements-ng) |
| ---------------- | ----------------------- | --------------------- |
| **Format**       | Self-contained function | ES modules            |
| **Dependencies** | External via globals    | Import statements     |
| **Shared libs**  | Manual DLL bundles      | Browser cache + CDN   |
| **Loading**      | Sequential scripts      | Parallel imports      |
| **Bundle size**  | Larger (IIFE wrapper)   | Smaller (no wrapper)  |
| **Caching**      | Per-bundle              | Per-module (better)   |
| **Complexity**   | High (custom tooling)   | Low (native)          |

---

## Why pie-elements-ng Is Moving to ESM

```mermaid
graph TB
    subgraph IIFE["IIFE Architecture (2017-2026)"]
        direction TB
        IIFESource[Element Source Code] --> IIFEBundler[pie-api-aws<br/>Bundler Service]
        IIFEBundler --> IIFEWebpack[Webpack + DLL Plugin]
        IIFEWebpack --> IIFEBundle[IIFE Bundle<br/>+ Shared Libs]
        IIFEBundle --> IIFECDN[CDN]
        IIFECDN --> IIFEBrowser[Browser<br/>window.pie]

        style IIFEBundler fill:#ffcccc
        style IIFEWebpack fill:#ffcccc
    end

    subgraph ESM["ESM Architecture (2026+)"]
        direction TB
        ESMSource[Element Source Code] --> ESMNPM[npm publish]
        ESMNPM --> ESMCDN[esm.sh CDN]
        ESMCDN --> ESMBrowser[Browser<br/>import {  }]

        style ESMNPM fill:#ccffcc
        style ESMCDN fill:#ccffcc
        style ESMBrowser fill:#ccffcc
    end
```

### Historical Context

PIE was started in 2017, when ESM (ECMAScript Modules) was not yet widely supported. At that time:

- Native browser ESM support was experimental
- No CDN ESM distribution existed (esm.sh, jspm, skypack didn't exist)
- Build tools like Webpack were essential for module bundling
- IIFE + DLL pattern was state-of-the-art for shared libraries

The IIFE architecture described above was the **correct solution for 2017**. It successfully:

- Avoided library duplication across elements
- Enabled efficient caching of shared libraries
- Worked reliably across all browsers

### Why ESM Now?

In 2026, the landscape has changed dramatically:

**Browser Support:**

- All modern browsers support ESM natively (95%+ global coverage)
- HTTP/2 makes parallel module loading efficient
- Import maps enable dependency resolution without build tools

**CDN Infrastructure:**

- esm.sh, jspm.dev, skypack.dev provide automatic ESM conversion
- NPM packages can be loaded directly as ESM
- Browser caching works at the module level (even better granularity)

**Developer Experience:**

- No build server required (pie-api-aws bundler not needed)
- Faster iteration (no webpack build step)
- Simpler deployment (just publish to NPM)
- Native browser tooling (source maps just work)

### Problems ESM Solves

#### 1. Eliminates Build Infrastructure

**IIFE approach:**

```mermaid
flowchart LR
    Dev[Developer] --> Bundler[pie-api-aws bundler]
    Bundler --> Webpack[webpack build]
    Webpack --> DLL[DLL bundles]
    DLL --> CDN
    CDN --> Browser

    style Bundler fill:#ffcccc
    style Webpack fill:#ffcccc
    style DLL fill:#ffcccc
```

**ESM approach:**

```mermaid
flowchart LR
    Dev[Developer] --> NPM[NPM publish]
    NPM --> CDN
    CDN --> Browser

    style NPM fill:#ccffcc
    style CDN fill:#ccffcc
    style Browser fill:#ccffcc
```

**Benefits:**

- No `pie-api-aws` bundler server to maintain
- No `pie-shared-lib-builder` tooling required
- No webpack configuration complexity
- No manifest.json generation
- Faster releases (just `npm publish`)

#### 2. Better Caching Granularity

**IIFE bundles:**

```mermaid
graph TD
    Bundle[math-rendering-module.js<br/>2.7MB - Single Cache Entry]
    Bundle --> MathJax[mathjax-full 2.5MB]
    Bundle --> Lodash[lodash 70KB]
    Bundle --> Debug[debug 10KB]
    Bundle --> Other[...]

    style Bundle fill:#ffcccc
    style MathJax fill:#ffcccc
    style Lodash fill:#ffcccc
    style Debug fill:#ffcccc
    style Other fill:#ffcccc

    Update[Update any dependency] -.->|Invalidates| Bundle
```

âŒ If any dependency updates, entire 2.7MB invalidated

**ESM modules:**

```mermaid
graph TD
    Pkg[@pie-lib/math-rendering]
    Pkg --> Index[index.js<br/>5KB<br/>âœ… Cached]
    Pkg --> Renderer[renderer.js<br/>95KB<br/>âœ… Cached]
    Pkg --> Utils[utils.js<br/>10KB<br/>âœ… Cached]

    style Index fill:#ccffcc
    style Renderer fill:#ccffcc
    style Utils fill:#ccffcc

    Update[Update renderer.js] -.->|Only invalidates| Renderer
```

âœ… Update one file, other files stay cached

**Impact:** Users download only what changed, not entire bundles.

#### 3. Smaller Bundle Sizes

**IIFE wrapper overhead:**

```javascript
var pie = (function() {
  'use strict';

  // Webpack runtime (~10-20KB)
  // Module loader boilerplate

  // Actual element code
  var MultipleChoice = ...;

  return { ... };
})();
```

**ESM (no wrapper):**

```javascript
// Just the code
export default function MultipleChoice() { ... }
```

**Savings:** 10-30KB per element bundle (5-15% reduction).

#### 4. Parallel Loading

**IIFE (sequential):**

```mermaid
sequenceDiagram
    participant Browser
    participant CDN

    Browser->>CDN: Load math-rendering-module.js (2.7MB)
    CDN-->>Browser: Wait... â³
    Note over Browser: Blocked, waiting...

    Browser->>CDN: Load pie-toolbox-module.js (1.5MB)
    CDN-->>Browser: Wait... â³
    Note over Browser: Blocked, waiting...

    Browser->>CDN: Load multiple-choice.js (200KB)
    CDN-->>Browser: Done
    Note over Browser: Finally ready!
```

**ESM (parallel):**

```mermaid
sequenceDiagram
    participant Browser
    participant CDN

    par Parallel Loading
        Browser->>CDN: math-rendering (100KB)
        Browser->>CDN: multiple-choice (200KB)
    and
        CDN-->>Browser: math-rendering âœ“
        CDN-->>Browser: multiple-choice âœ“
    end
    Note over Browser: All loaded simultaneously!
```

**Impact:** Faster initial load (HTTP/2 multiplexing).

#### 5. Version Management Simplified

**IIFE approach:**

```typescript
// Complex webpack plugin to handle version conflicts
new NormalModuleReplacementPlugin(
  /@pie-lib\/(math-rendering|pie-toolbox)/,
  (resource) => {
    // Custom logic to resolve per-element versions
    // Webpack aliases for each version
  },
);
```

**ESM approach:**

```javascript
// Browser handles it natively via import maps
{
  "imports": {
    "@pie-lib/math-rendering": "https://esm.sh/@pie-lib/math-rendering@4.1.0"
  }
}
```

**Benefits:**

- No custom webpack plugins
- Standard browser feature
- Easy to override per element if needed

#### 6. Development Experience

**IIFE workflow:**

```bash
# 1. Make changes to element
vim packages/multiple-choice/src/index.ts

# 2. Build element locally
cd packages/multiple-choice && npm run build

# 3. Request bundler to build IIFE
curl -X POST pie-api-aws/bundler/build

# 4. Wait for webpack to run (~30-60s)

# 5. Deploy to CDN

# 6. Test in browser
```

**ESM workflow:**

```bash
# 1. Make changes
vim packages/multiple-choice/src/index.ts

# 2. Publish to NPM
npm publish

# 3. Test immediately
# Browser loads from esm.sh automatically
```

**Time savings:** Minutes per iteration â†’ seconds per iteration.

### Challenges with ESM

#### 1. Browser Compatibility

**Issue:** Older browsers (IE11, pre-2020 Chrome/Safari) don't support ESM.

**Solution:**

- Modern browsers only (95%+ coverage in 2026)
- Provide IIFE fallback if needed (can still generate)
- Most educational platforms require modern browsers anyway

#### 2. Import Maps Support

**Issue:** Import maps not universally supported until ~2023.

**Solution:**

- Polyfill available: `es-module-shims`
- Native support now at 90%+ coverage
- Can inline imports if import maps unavailable

#### 3. Bare Imports Not Supported

**Issue:** Browsers don't resolve `import 'react'` (bare specifiers).

**Solution:**

- Use full URLs: `import 'https://esm.sh/react@18'`
- Or use import maps to resolve bare specifiers
- Build step can rewrite imports if needed

#### 4. No Tree-Shaking by Default

**Issue:** Browser loads entire module even if only using one export.

**Solution:**

- Author packages with explicit exports
- Use subpath exports: `@pkg/foo/bar` instead of `@pkg` with deep imports
- ESM CDNs (esm.sh) can tree-shake on server

#### 5. HTTP Request Count

**Issue:** Many small modules = many HTTP requests.

**Concern:** "Won't this be slower than bundled IIFE?"

**Reality:**

- HTTP/2 makes parallel requests cheap
- Browser caching means most requests are cache hits
- Granular caching often faster than large bundle re-download
- CDNs optimize module serving

**Mitigation:**

- Bundle "hot path" code together
- Lazy load infrequent features
- Use HTTP/2 server push if needed

#### 6. Debugging Complexity

**Issue:** More modules = harder to debug in browser DevTools.

**Solution:**

- Source maps work natively (simpler than IIFE source maps)
- Browser DevTools improved ESM debugging
- Module boundaries actually make debugging easier (clearer separation)

### Migration Path

pie-elements-ng uses a **hybrid approach** during transition:

1. **Elements are authored as ESM** (source code is ESM-first)
2. **Published as ESM to NPM** (native modules)
3. **Can generate IIFE bundles if needed** (for backwards compatibility)
4. **Math rendering uses MathJax v4** (2.7MB, same as upstream, but CDN-loaded for ESM)

This allows:

- New deployments to use ESM (modern, efficient, CDN-cached MathJax)
- Legacy deployments to use IIFE (if required)
- Full accessibility support (WCAG AAA via Speech Rule Engine)
- Gradual migration without breaking changes

### Real-World Impact

```mermaid
graph LR
    subgraph IIFE["IIFE Bundle Size"]
        direction TB
        I1[First Load:<br/>2.9MB]
        I2[+ Element 2:<br/>+200KB]
        I3[+ Element 3:<br/>+180KB]
        I4[Total: 3.3MB]

        I1 --> I2 --> I3 --> I4

        style I1 fill:#ffcccc
        style I2 fill:#ffdddd
        style I3 fill:#ffdddd
        style I4 fill:#ff9999
    end

    subgraph ESM["ESM Bundle Size"]
        direction TB
        E1[First Load:<br/>300KB]
        E2[+ Element 2:<br/>+200KB]
        E3[+ Element 3:<br/>+180KB]
        E4[Total: 680KB<br/>ğŸ‰ 79% smaller!]

        E1 --> E2 --> E3 --> E4

        style E1 fill:#ccffcc
        style E2 fill:#ddffdd
        style E3 fill:#ddffdd
        style E4 fill:#99ff99
    end
```

**IIFE bundle (current):**

```text
First load: 2.9MB (2.7MB shared lib + 200KB element)
Second element: +200KB (lib cached)
Third element: +180KB (lib cached)
Total: 3.3MB
```

**ESM bundle (pie-elements-ng with MathJax v4):**

```text
First load: 2.9MB (2.7MB MathJax v4 from CDN + 200KB element)
Second element: +200KB (MathJax cached by browser)
Third element: +180KB (MathJax cached by browser)
Total: 3.3MB (same size, but native browser caching + full accessibility)
```

**Note:** Bundle sizes are comparable to IIFE, but ESM provides:

- **Full accessibility**: WCAG AAA compliance via Speech Rule Engine
- **Native MathML support**: 100% fidelity, no conversion loss
- **No bundler server infrastructure** (~$1000s/mo savings)
- **Faster developer iteration** (minutes â†’ seconds)
- **Simpler deployment pipeline** (npm publish vs bundler + CDN sync)
- **Better browser caching** (per-module vs per-bundle)
- **Native debugging** (no webpack source map complexity)
- **CDN-loaded MathJax** (cached across all PIE deployments globally)

---

## Controller Bundling Architecture

### Overview

Controllers are bundled **separately** from player bundles and follow a different strategy.

### Controller Bundle Process

**Location:** `kds/pie-api-aws/packages/bundler/src/webpack/controller.ts`

#### Key Differences from Player Bundles

**Player bundles:**
- Mark shared libraries as **externals** (not bundled)
- References: `@pie-lib/pie-toolbox`, `@pie-lib/math-rendering`
- Bundle size: ~200KB (without shared libs)

**Controller bundles:**
- **NO externals** - everything is bundled together
- Self-contained CommonJS bundle
- Bundle size: varies (~500KB-1MB with all dependencies)

#### Webpack Configuration

```typescript
// controller.ts (simplified)
const options: Configuration = {
  target: 'web',
  mode: 'production',
  entry: { controller: '@pie-element/multiple-choice/controller' },

  // NO externals configuration
  // All dependencies are bundled into the controller

  output: {
    filename: '[name].js',
    libraryTarget: 'commonjs2',  // â† CommonJS, not IIFE
    path: join(rootDir, 'dist'),
  },

  resolve: {
    modules: [join(srcSnapshot.rootDir, 'node_modules'), 'node_modules'],
  },

  optimization: {
    minimize: true,
    minimizer: [new EsbuildPlugin({ target: 'es2015', format: 'cjs' })],
  },
};
```

### Dependency Installation

**Step 1: Download from NPM**

```typescript
// installer.ts:75-95
await pacote.tarball.stream(
  `${dependency.name}@${dependency.version}`,
  tarballStreamHandler(pkgPath, dependency.name),
  {
    registry: process.env.REGISTRY_URL || 'https://registry.npmjs.org/',
    timeout: 30000,
  }
);
```

Controllers are downloaded from the **standard NPM registry** (not a custom location).

**Step 2: Install All Dependencies**

```typescript
// srcSnapshot.ts:86
const result = await this.installer.install(deps, tmpDir);

// Uses yarn to install:
// - Element package
// - Controller dependencies (from controller/package.json)
// - ALL transitive dependencies
```

**Step 3: Bundle Everything**

```typescript
// controllerBundler.ts:43-49
const bundleResult = await this.bundler.bundle(
  {
    controller: controllerPkgName,  // e.g., '@pie-element/multiple-choice/controller'
  },
  srcSnapshot,  // Contains full node_modules with all dependencies
  tmpDir
);
```

### What Gets Bundled into Controllers

**Example: Multiple Choice Controller**

```
controller.js (~800KB minified)
â”œâ”€â”€ Controller logic (50KB)
â”œâ”€â”€ lodash (70KB)
â”œâ”€â”€ @pie-framework/math-validation (200KB)
â”œâ”€â”€ @pie-lib/controller-utils (100KB)
â”œâ”€â”€ Other dependencies (380KB)
â””â”€â”€ Webpack runtime (minimal, ~10KB)
```

**All external dependencies are bundled:**
- `@pie-framework/math-validation`
- `lodash`, `lodash-es`
- `debug`
- Any other npm dependencies from controller's `package.json`

### Why Controllers Bundle Everything

**Isolation:**
- Controllers run in assessment scoring environments
- Need to be fully self-contained
- Can't rely on external shared libraries
- Must work offline or in restricted environments

**Consistency:**
- Controller logic must produce identical results
- Version pinning ensures reproducibility
- No shared library version conflicts

**Security:**
- Scoring happens server-side in many cases
- Self-contained bundle reduces attack surface
- All dependencies are audited and bundled together

### pie-elements-ng Compatibility

**Current Approach:**
```
packages/elements-react/multiple-choice/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ index.ts          # Player component
â”‚   â”œâ”€â”€ delivery/         # Delivery view
â”‚   â”œâ”€â”€ author/           # Authoring view
â”‚   â””â”€â”€ controller/       # Controller logic
â”‚       â”œâ”€â”€ index.ts
â”‚       â””â”€â”€ package.json  # â† Controller dependencies declared here
â””â”€â”€ package.json          # Element dependencies
```

**What Happens in pie-api-aws:**

1. **Download** `@pie-element/multiple-choice` from NPM
2. **Read** controller package.json at `controller/package.json`
3. **Install** all dependencies via yarn (including controller deps)
4. **Bundle** controller with webpack (all deps included)
5. **Result** Self-contained `controller.js` (~800KB)

**Tree Shaking:**
- Webpack bundles only imported code
- Unused exports from dependencies are eliminated
- Minification reduces size further
- Example: Only used lodash functions are bundled

**External Dependencies:**
- pie-api-aws **automatically installs** controller dependencies
- Reads from `controller/package.json`
- Runs `yarn install` in snapshot directory
- All deps available during bundling

**Local Development:**
- Need controller external deps in root `package.json` for dev server
- Example: `@pie-framework/math-validation` needed locally
- In production, pie-api-aws handles this automatically

### Bundle Size Comparison

**IIFE Player Bundle:**
```
multiple-choice player.js
â”œâ”€â”€ Player component: 150KB
â”œâ”€â”€ React/UI code: 50KB
â”œâ”€â”€ No shared libs (external)
â””â”€â”€ Total: ~200KB
```

**Controller Bundle:**
```
multiple-choice controller.js
â”œâ”€â”€ Controller logic: 50KB
â”œâ”€â”€ All dependencies bundled: 750KB
â””â”€â”€ Total: ~800KB
```

**Why the Size Difference?**
- Controllers can't use shared libraries (isolated execution)
- Players reference shared libs (loaded once, cached)
- Controllers need to be self-contained for scoring environments

### Deployment Flow

```mermaid
sequenceDiagram
    participant Dev as Developer
    participant NPM as NPM Registry
    participant Builder as pie-api-aws Builder
    participant CDN as CDN

    Dev->>NPM: npm publish @pie-element/multiple-choice@12.0.0
    Note over NPM: Package includes:<br/>- Player code<br/>- Controller code<br/>- controller/package.json

    Builder->>NPM: Download @pie-element/multiple-choice@12.0.0
    NPM-->>Builder: Tarball with all code

    Builder->>NPM: yarn install (resolves controller deps)
    NPM-->>Builder: Installs @pie-framework/math-validation, etc.

    Builder->>Builder: Webpack bundle controller<br/>(all deps included)

    Builder->>CDN: Upload controller.js (~800KB)
    CDN-->>Builder: Ready

    Note over CDN: Controller is now available:<br/>https://cdn.example.com/bundles/<br/>@pie-element/multiple-choice@12.0.0/<br/>controller.js
```

### Key Insights

1. **Controllers are self-contained** - all dependencies bundled
2. **Players use externals** - shared libraries not bundled
3. **Automatic dependency resolution** - pie-api-aws installs from controller/package.json
4. **Local dev needs manual setup** - add external deps to root package.json
5. **Tree shaking works** - only imported code is bundled
6. **CommonJS output** - not IIFE, not ESM (for Node.js compatibility)

---

## Key Insights for pie-elements-ng

### 1. Math Rendering Must Be External

In IIFE bundles, `@pie-lib/math-rendering` is **NOT** bundled into each element. It's:

- Built as a separate shared library
- Loaded once by the browser
- Referenced by all elements

**This is why the upstream approach works:**

- Elements don't bundle 2.7MB of MathJax each
- Shared library is loaded once and cached
- Elements just reference `window['_dll_pie_lib__math_rendering']`

### 2. ESM Can Do Better

With native ESM:

```javascript
// Element
import { renderMath } from "https://esm.sh/@pie-lib/math-rendering@4.1.0";

// Browser automatically:
// - Caches the module
// - Shares it across elements
// - Parallelizes loading
```

No custom DLL plugin or manifest needed!

### 3. The Wrapper Approach is Correct

For pie-elements-ng:

```typescript
// @pie-lib/math-rendering wraps MathJax v4
export { renderMath, wrapMath, unWrapMath, mmlToLatex } from '@pie-element/shared-math-rendering-mathjax';
```

**Why this works:**

- Elements import from `@pie-lib/math-rendering` (same as upstream)
- Wrapper re-exports from MathJax v4 (full feature parity)
- When elements are bundled as IIFE, wrapper is still external
- Browser only loads one copy (CDN-cached MathJax for ESM, DLL bundle for IIFE)
- Full accessibility support maintained

---

## Summary

### How IIFE Bundles Work

1. **Shared libraries** (like `@pie-lib/math-rendering`) are built as DLL modules
2. **Element bundles** externalize shared libraries
3. **Browser** loads shared libs first, then elements
4. **Elements** reference shared libs via global variables
5. **Result:** Minimal duplication, cached libraries

### Math Rendering in IIFE

- `@pie-lib/math-rendering` is a **2.7MB shared library**
- Elements **don't bundle it** - they reference it externally
- Loaded **once per page** and cached
- All elements share the same instance

### Implications for pie-elements-ng

- The **wrapper approach is validated** - upstream also externalizes math-rendering
- Elements don't bundle it either way (IIFE external or ESM import)
- The 2.7MB cost is **paid once** regardless of approach (MathJax v4 in both cases)
- **ESM loads MathJax from CDN** - cached globally across all PIE deployments
- **Full accessibility maintained** - WCAG AAA compliance via Speech Rule Engine

The key difference: IIFE uses manual DLL tooling, ESM uses native browser module caching + CDN. Both avoid duplication, but ESM is simpler and provides better global caching (jsdelivr CDN vs per-deployment CDN).

---

## The Custom Elements Global Namespace Problem

### The Fundamental Tension

There's an architectural tension between **ESM module scope** and **custom elements global registration**:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ESM Modules: Local Scope               â”‚
â”‚  âœ… Can import multiple versions        â”‚
â”‚  âœ… Module instances are isolated       â”‚
â”‚  âœ… Each import gets its own context    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
                  â”‚ But must register to...
                  â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  customElements: Global to Page         â”‚
â”‚  âŒ Cannot register same tag twice      â”‚
â”‚  âŒ No scoping mechanism exists         â”‚
â”‚  âŒ Permanent for page lifetime         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### The Problem in Detail

**ESM allows multiple versions:**

```javascript
// Module A imports version 1.0
import Element_v1 from 'https://esm.sh/@pie-element/multiple-choice@1.0.0';

// Module B imports version 2.0
import Element_v2 from 'https://esm.sh/@pie-element/multiple-choice@2.0.0';

// Both modules loaded successfully! âœ…
```

**But custom element registration is global:**

```javascript
// Module A tries to register
customElements.define('multiple-choice', Element_v1);  // âœ… Works

// Module B tries to register the same tag
customElements.define('multiple-choice', Element_v2);
// âŒ DOMException: Failed to execute 'define' on 'CustomElementRegistry':
//    the name "multiple-choice" has already been used with this registry
```

**Key facts about `customElements`:**

1. **Singleton per document** - only one registry per page
2. **Cannot undefine** - once registered, permanent until page reload
3. **Cannot redefine** - same tag name cannot be registered twice
4. **No namespacing** - no way to scope tags to components or modules
5. **Globally accessible** - `window.customElements` everywhere

### Why This Matters for PIE

**Scenario:** An assessment page needs two elements that depend on different versions:

```
Assessment Item:
â”œâ”€â”€ multiple-choice (depends on @pie-lib/render-ui@5.0.0)
â””â”€â”€ drag-in-the-blank (depends on @pie-lib/render-ui@6.0.0)
```

**Without versioned tags:**
```javascript
// First element loads
customElements.define('multiple-choice', MultipleChoiceClass_v1);  // âœ…

// Second element tries to load (different version)
customElements.define('multiple-choice', MultipleChoiceClass_v2);  // âŒ ERROR!
```

The browser **cannot** distinguish between versions using the same tag name.

### The Solution: Versioned Tag Names

Both **pie-players** and **pie-elements-ng** solve this using **version-encoded tag names**:

#### Implementation in pie-players

**File:** `packages/players-shared/src/pie/config.ts`

```typescript
/**
 * We make the web component name unique by using the version number. This is needed
 * because the spec doesn't allow for removing/updating a custom element definition
 * once it's been defined. This is a workaround to ensure that the custom element
 * is redefined when the version changes.
 */
export const makeUniqueTags = <T extends ConfigContainerEntity>(container: T): T => {
  const VERSION_DELIMITER = "--version-";

  const createVersionedName = (elName: string, pkg: string): string => {
    const { baseName, existingVersion } = parseElementName(elName);
    const { version } = parsePackageName(pkg);

    if (existingVersion !== version) {
      return `${baseName}${VERSION_DELIMITER}${version.replace(/\./g, "-")}`;
    }
    return elName;
  };

  // Transform markup and model references
  // ...
}
```

**Example transformation:**

```html
<!-- Original markup -->
<multiple-choice id="1"></multiple-choice>

<!-- After makeUniqueTags() with version 11.2.0 -->
<multiple-choice--version-11-2-0 id="1"></multiple-choice--version-11-2-0>

<!-- After makeUniqueTags() with version 12.0.0 -->
<multiple-choice--version-12-0-0 id="1"></multiple-choice--version-12-0-0>
```

**Now both versions can coexist:**

```javascript
customElements.define('multiple-choice--version-11-2-0', MultipleChoiceClass_v11);  // âœ…
customElements.define('multiple-choice--version-12-0-0', MultipleChoiceClass_v12);  // âœ…
```

### Why Global State is Actually Correct

Since custom elements are inherently global, **tracking them globally makes sense**:

#### pie-players Approach: `window.PIE_REGISTRY`

```typescript
// packages/players-shared/src/pie/registry.ts
export const pieRegistry = (): PieRegistry => {
  let registry: PieRegistry;
  if (isPieRegistryAvailable(window)) {
    registry = window.PIE_REGISTRY;
  } else {
    registry = {};
    (window as any).PIE_REGISTRY = registry;
  }
  return registry;
};
```

**What the registry tracks:**

```typescript
interface Entry {
  package: string;              // "@pie-element/multiple-choice@12.0.0"
  status: Status;               // 'loading' | 'loaded'
  tagName: string;              // "multiple-choice--version-12-0-0"
  controller?: PieController;   // Controller instance
  element?: any;                // Element class
  bundleType?: BundleType;      // 'esm' | 'iife'
}

// Global registry
window.PIE_REGISTRY = {
  'multiple-choice--version-11-2-0': {
    package: '@pie-element/multiple-choice@11.2.0',
    status: 'loaded',
    controller: { model: ..., score: ... }
  },
  'multiple-choice--version-12-0-0': {
    package: '@pie-element/multiple-choice@12.0.0',
    status: 'loaded',
    controller: { model: ..., score: ... }
  }
};
```

**Why global state is appropriate:**

1. **Aligns with platform** - `customElements` is already global
2. **Prevents duplicate loading** - check registry before loading
3. **Enables controller lookup** - map tag name to controller
4. **Coordinates multiple players** - share state across player instances
5. **Tracks loading status** - know what's already available

#### Alternative: Use customElements Directly?

**Could we avoid `window.PIE_REGISTRY` and just use `customElements`?**

```javascript
// Check if already registered
if (customElements.get('multiple-choice--version-12-0-0')) {
  console.log('Already registered');
}
```

**This works for checking registration, but:**

âŒ **Where do you store the controller?**
```javascript
// Need to associate controller with tag somehow...
// Still need global state!
```

âŒ **How do you track loading status?**
```javascript
// customElements doesn't tell you if something is currently loading
// Still need to track this globally!
```

âŒ **How do you find package version from tag?**
```javascript
// customElements.get() returns the class, not metadata
// Still need global metadata store!
```

**Conclusion:** You need global state anyway. `window.PIE_REGISTRY` is the honest approach.

### Registration Pattern with Checks

Both projects check before registering:

**ESM Loader (pie-players):**

```typescript
// packages/players-shared/src/pie/esm-loader.ts
if (!customElements.get(tag)) {
  if (isCustomElementConstructor(ElementClass)) {
    // Wrap to allow multiple registrations with same constructor
    customElements.define(tag, class extends ElementClass {});
    logger.debug(`Registered custom element: ${tag}`);

    registry[tag] = {
      ...registry[tag],
      status: Status.loaded,
    };
  }
} else {
  logger.debug(`Element ${tag} already registered`);
  registry[tag] = {
    ...registry[tag],
    status: Status.loaded,
  };
}
```

**Element Loader (pie-elements-ng):**

```typescript
// packages/element-player/src/lib/element-loader.ts
export async function loadElement(
  packagePath: string,
  tagName: string,
  cdnUrl: string
): Promise<void> {
  // Check if already registered
  if (customElements.get(tagName)) {
    if (debug) console.log(`Element ${tagName} already registered`);
    return;
  }

  // Load and register
  const module = await import(/* @vite-ignore */ modulePath);
  const ElementClass = module.default || module.Element;

  customElements.define(tagName, ElementClass);
  await customElements.whenDefined(tagName);
}
```

### Class Wrapping Technique

**Why wrap the element class?**

```typescript
customElements.define(tag, class extends ElementClass {});
```

This allows:

1. **Multiple versions using same base class** - each gets unique subclass
2. **Bypasses constructor reference check** - each wrapper is a new class
3. **Preserves element behavior** - inheritance maintains all functionality

**Without wrapping:**

```javascript
// If two versions try to register with same constructor
customElements.define('tag-v1', SameClass);  // âœ…
customElements.define('tag-v2', SameClass);  // âŒ May fail in some browsers
```

**With wrapping:**

```javascript
customElements.define('tag-v1', class extends SameClass {});  // âœ…
customElements.define('tag-v2', class extends SameClass {});  // âœ…
// Each gets a unique class instance
```

### Coordination Across the Page

**Why this matters for multiple players on one page:**

```html
<!-- Page with two assessment players -->
<div id="assessment-1">
  <pie-esm-player config='{"elements": {...}}'></pie-esm-player>
</div>

<div id="assessment-2">
  <pie-esm-player config='{"elements": {...}}'></pie-esm-player>
</div>
```

**Without global registry:**
- Player 1 loads `multiple-choice--version-12-0-0`
- Player 2 also needs `multiple-choice--version-12-0-0`
- Both try to `customElements.define()` â†’ âŒ Second one fails

**With global registry:**
- Player 1 loads and registers element, updates registry
- Player 2 checks registry, sees element already loaded
- Player 2 skips registration, uses existing definition â†’ âœ…

### ESM vs IIFE: Same Problem, Different Scale

**IIFE bundles:**
- Use `window.pie` to expose elements
- Global state is explicit and expected
- DLL shared libraries also use globals

**ESM modules:**
- Import statements feel "local" and modular
- But `customElements.define()` is still global
- The illusion of module isolation breaks at registration

**Both need versioned tags and global coordination.**

### Import Maps Don't Solve This

**Import maps handle module resolution:**

```html
<script type="importmap">
{
  "imports": {
    "multiple-choice": "https://esm.sh/@pie-element/multiple-choice@12.0.0"
  }
}
</script>
```

**But they don't scope custom element registration:**

```javascript
import Element from 'multiple-choice';  // âœ… Import maps work here

customElements.define('multiple-choice', Element);  // âŒ Still global!
```

Import maps only control **where modules come from**, not **how they register**.

### Future Web Platform?

**Potential future solutions (not yet available):**

1. **Scoped Custom Element Registries** - Allow per-component registries
   - Proposal: https://github.com/WICG/webcomponents/issues/716
   - Status: Early discussion, not implemented

2. **Shadow DOM Registries** - Scope elements to shadow root
   - Would require each player to use shadow DOM
   - Breaks global styling and CSS inheritance

3. **Module Blocks** - Inline modules with private scope
   - Still experimental
   - Doesn't solve custom element registration

**Current reality:** Versioned tag names are the only practical solution.

### Key Takeaways

1. **Custom elements are inherently global** - no scoping mechanism exists
2. **ESM module scope is an illusion** - breaks at custom element registration
3. **Versioned tag names are necessary** - allow multiple versions to coexist
4. **Global state is correct** - aligns with the platform's global registry
5. **Both IIFE and ESM need this** - the problem is independent of bundle format
6. **Check before registering** - `customElements.get()` prevents errors
7. **Class wrapping enables reuse** - same base class, different subclasses

The `window.PIE_REGISTRY` in pie-players is not a workaround or anti-pattern - it's the **correct architectural response** to the web platform's global custom element namespace. Since `customElements` is global, tracking elements globally is the honest, maintainable approach.
