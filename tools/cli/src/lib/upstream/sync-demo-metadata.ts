/**
 * Generate demo metadata for SvelteKit demo app
 *
 * This module generates:
 * 1. Element registry (lib/elements/registry.ts)
 * 2. Sample configs converted to JSON from each element
 * 3. Sample sessions converted to JSON from each element
 */
import { mkdir, writeFile } from 'node:fs/promises';
import { join, dirname } from 'node:path';
import { fileURLToPath } from 'node:url';

const __dirname = dirname(fileURLToPath(import.meta.url));
const REPO_ROOT = join(__dirname, '../../../../..');
const DEMO_APP_PATH = join(REPO_ROOT, 'apps/element-demo');
const ELEMENTS_REACT_PATH = join(REPO_ROOT, 'packages/elements-react');

export interface ElementMetadata {
  name: string;
  title: string;
  packageName: string;
  hasAuthor: boolean;
  hasPrint: boolean;
  hasConfig: boolean;
  hasSession: boolean;
}

/**
 * Scan elements-react directory for all elements
 */
async function scanReactElements(): Promise<ElementMetadata[]> {
  const { readdirSync, existsSync: fsExistsSync, statSync } = await import('node:fs');

  if (!fsExistsSync(ELEMENTS_REACT_PATH)) {
    console.log('[demo-metadata] elements-react directory not found, skipping');
    return [];
  }

  const elements: ElementMetadata[] = [];
  const dirs = readdirSync(ELEMENTS_REACT_PATH);

  for (const dir of dirs) {
    const elementPath = join(ELEMENTS_REACT_PATH, dir);
    const stat = statSync(elementPath);

    if (!stat.isDirectory()) continue;

    // Check for required structure
    const srcPath = join(elementPath, 'src');
    const deliveryPath = join(srcPath, 'delivery');
    if (!fsExistsSync(deliveryPath)) continue;

    // Check for author and print
    const hasAuthor = fsExistsSync(join(srcPath, 'author'));
    const hasPrint = fsExistsSync(join(srcPath, 'print'));

    // Check for demo files
    const docsPath = join(elementPath, 'docs/demo');
    const hasConfig = fsExistsSync(join(docsPath, 'config.mjs'));
    const hasSession = fsExistsSync(join(docsPath, 'session.mjs'));

    // Generate title from name (e.g., "multiple-choice" -> "Multiple Choice")
    const title = dir
      .split('-')
      .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
      .join(' ');

    elements.push({
      name: dir,
      title,
      packageName: `@pie-element/${dir}`,
      hasAuthor,
      hasPrint,
      hasConfig,
      hasSession,
    });
  }

  return elements;
}

/**
 * Generate registry.ts file
 */
async function generateRegistry(elements: ElementMetadata[]): Promise<void> {
  const registryPath = join(DEMO_APP_PATH, 'src/lib/elements/registry.ts');

  const content = `/**
 * Element Registry
 *
 * AUTO-GENERATED by upstream:sync command.
 * DO NOT EDIT MANUALLY - changes will be overwritten.
 *
 * Generated: ${new Date().toISOString()}
 */

export interface ElementMetadata {
  name: string;
  title: string;
  packageName: string;
  hasAuthor: boolean;
  hasPrint: boolean;
  hasConfig: boolean;
  hasSession: boolean;
}

export const ELEMENT_REGISTRY: readonly ElementMetadata[] = ${JSON.stringify(elements, null, 2)};

export function getElement(name: string): ElementMetadata | undefined {
  return ELEMENT_REGISTRY.find((el) => el.name === name);
}

export function getAllElements(): ElementMetadata[] {
  return ELEMENT_REGISTRY;
}
`;

  await mkdir(dirname(registryPath), { recursive: true });
  await writeFile(registryPath, content, 'utf-8');
  console.log(`[demo-metadata] Generated registry with ${elements.length} elements`);
}

/**
 * Convert and copy sample configs for an element as JSON
 */
async function copySampleConfigs(elements: ElementMetadata[]): Promise<void> {
  for (const element of elements) {
    const sourcePath = join(ELEMENTS_REACT_PATH, element.name, 'docs/demo');
    const targetDir = join(DEMO_APP_PATH, 'src/lib/data/sample-configs/react');
    await mkdir(targetDir, { recursive: true });

    // Convert config.mjs to JSON
    if (element.hasConfig) {
      const sourceConfig = join(sourcePath, 'config.mjs');
      const targetConfig = join(targetDir, `${element.name}.json`);
      try {
        // Dynamic import the .mjs file
        const configModule = await import(`file://${sourceConfig}`);
        const configData = configModule.default;

        // Write as JSON
        await writeFile(targetConfig, JSON.stringify(configData, null, 2) + '\n', 'utf-8');
      } catch (e) {
        console.warn(`[demo-metadata] Failed to convert config for ${element.name}:`, e);
      }
    }

    // Convert session.mjs to JSON
    if (element.hasSession) {
      const sourceSession = join(sourcePath, 'session.mjs');
      const targetSession = join(targetDir, `${element.name}-session.json`);
      try {
        // Dynamic import the .mjs file
        const sessionModule = await import(`file://${sourceSession}`);
        const sessionData = sessionModule.default;

        // Write as JSON
        await writeFile(targetSession, JSON.stringify(sessionData, null, 2) + '\n', 'utf-8');
      } catch (e) {
        console.warn(`[demo-metadata] Failed to convert session for ${element.name}:`, e);
      }
    }
  }

  console.log(`[demo-metadata] Converted sample configs to JSON for ${elements.length} elements`);
}

/**
 * Main entry point
 */
export async function generateDemoMetadata(): Promise<void> {
  console.log('[demo-metadata] Scanning elements...');

  const reactElements = await scanReactElements();
  const allElements = [...reactElements].sort((a, b) => a.name.localeCompare(b.name));

  console.log(`[demo-metadata] Found ${reactElements.length} React elements`);

  await generateRegistry(allElements);
  await copySampleConfigs(allElements);

  console.log('[demo-metadata] âœ“ Demo metadata generation complete');
}
