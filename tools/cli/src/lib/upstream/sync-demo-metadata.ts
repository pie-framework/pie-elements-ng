/**
 * Generate demo metadata for SvelteKit demo app
 *
 * This module generates:
 * 1. Element registry (lib/elements/registry.ts)
 * 2. Sample configs converted to JSON from each element
 * 3. Sample sessions converted to JSON from each element
 */
import { mkdir, writeFile } from 'node:fs/promises';
import { join, dirname } from 'node:path';
import { fileURLToPath } from 'node:url';

const __dirname = dirname(fileURLToPath(import.meta.url));
const REPO_ROOT = join(__dirname, '../../../../..');
const DEMO_APP_PATH = join(REPO_ROOT, 'apps/element-demo');
const ELEMENTS_REACT_PATH = join(REPO_ROOT, 'packages/elements-react');

export interface ElementMetadata {
  name: string;
  title: string;
  packageName: string;
  hasAuthor: boolean;
  hasPrint: boolean;
  hasConfig: boolean;
  hasSession: boolean;
  demoCount: number;
}

/**
 * Scan elements-react directory for all elements
 */
async function scanReactElements(): Promise<ElementMetadata[]> {
  const { readdirSync, existsSync: fsExistsSync, statSync } = await import('node:fs');

  if (!fsExistsSync(ELEMENTS_REACT_PATH)) {
    console.log('[demo-metadata] elements-react directory not found, skipping');
    return [];
  }

  const elements: ElementMetadata[] = [];
  const dirs = readdirSync(ELEMENTS_REACT_PATH);

  for (const dir of dirs) {
    const elementPath = join(ELEMENTS_REACT_PATH, dir);
    const stat = statSync(elementPath);

    if (!stat.isDirectory()) continue;

    // Check for required structure
    const srcPath = join(elementPath, 'src');
    const deliveryPath = join(srcPath, 'delivery');
    if (!fsExistsSync(deliveryPath)) continue;

    // Check for author and print
    const hasAuthor = fsExistsSync(join(srcPath, 'author'));
    const hasPrint = fsExistsSync(join(srcPath, 'print'));

    // Check for demo files
    const docsPath = join(elementPath, 'docs/demo');
    const hasConfig = fsExistsSync(join(docsPath, 'config.mjs'));
    const hasSession = fsExistsSync(join(docsPath, 'session.mjs'));

    // Generate title from name (e.g., "multiple-choice" -> "Multiple Choice")
    const title = dir
      .split('-')
      .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
      .join(' ');

    elements.push({
      name: dir,
      title,
      packageName: `@pie-element/${dir}`,
      hasAuthor,
      hasPrint,
      hasConfig,
      hasSession,
      demoCount: 0, // Will be updated in copySampleConfigs
    });
  }

  return elements;
}

/**
 * Generate registry.ts file
 */
async function generateRegistry(elements: ElementMetadata[]): Promise<void> {
  const registryPath = join(DEMO_APP_PATH, 'src/lib/elements/registry.ts');

  const content = `/**
 * Element Registry
 *
 * AUTO-GENERATED by upstream:sync command.
 * DO NOT EDIT MANUALLY - changes will be overwritten.
 *
 * Generated: ${new Date().toISOString()}
 */

export interface ElementMetadata {
  name: string;
  title: string;
  packageName: string;
  hasAuthor: boolean;
  hasPrint: boolean;
  hasConfig: boolean;
  hasSession: boolean;
  demoCount: number;
}

export const ELEMENT_REGISTRY: readonly ElementMetadata[] = ${JSON.stringify(elements, null, 2)};

export function getElement(name: string): ElementMetadata | undefined {
  return ELEMENT_REGISTRY.find((el) => el.name === name);
}

export function getAllElements(): ElementMetadata[] {
  return ELEMENT_REGISTRY;
}
`;

  await mkdir(dirname(registryPath), { recursive: true });
  await writeFile(registryPath, content, 'utf-8');
  console.log(`[demo-metadata] Generated registry with ${elements.length} elements`);
}

/**
 * Convert and copy sample configs for an element as JSON
 */
async function copySampleConfigs(elements: ElementMetadata[]): Promise<void> {
  for (const element of elements) {
    const sourcePath = join(ELEMENTS_REACT_PATH, element.name, 'docs/demo');
    const targetDir = join(DEMO_APP_PATH, 'src/lib/data/sample-configs/react');
    await mkdir(targetDir, { recursive: true });

    // Convert config.mjs to JSON
    if (element.hasConfig) {
      const sourceConfig = join(sourcePath, 'config.mjs');
      const targetConfig = join(targetDir, `${element.name}.json`);
      try {
        // Dynamic import the .mjs file
        const configModule = await import(`file://${sourceConfig}`);
        let configData = configModule.default;

        // Convert old format (models array) to new format (demos array)
        if (configData?.models && !configData?.demos) {
          console.log(`[demo-metadata] Converting ${element.name} from old format to new format`);
          configData = {
            demos: configData.models.map((model: any, index: number) => ({
              id: index === 0 ? 'default' : `demo-${index + 1}`,
              title: index === 0 ? 'Default Demo' : `Demo ${index + 1}`,
              description: 'Default configuration',
              tags: [],
              model: model,
              session: { value: [] },
            })),
          };
        }

        // Count demos (now all in 'demos' format)
        if (configData?.demos && Array.isArray(configData.demos)) {
          element.demoCount = configData.demos.length;
        } else {
          element.demoCount = 0;
        }

        // Write as JSON
        await writeFile(targetConfig, JSON.stringify(configData, null, 2) + '\n', 'utf-8');
      } catch (e) {
        console.warn(`[demo-metadata] Failed to convert config for ${element.name}:`, e);
      }
    }

    // Note: session.mjs files are no longer copied as separate files.
    // Sessions are now embedded within each demo object in the config.
    // Old format session files are automatically converted during config import above.
  }

  console.log(`[demo-metadata] Converted sample configs to JSON for ${elements.length} elements`);
}

/**
 * Main entry point
 */
export async function generateDemoMetadata(): Promise<void> {
  console.log('[demo-metadata] Scanning elements...');

  const reactElements = await scanReactElements();
  const allElements = [...reactElements].sort((a, b) => a.name.localeCompare(b.name));

  console.log(`[demo-metadata] Found ${reactElements.length} React elements`);

  // Copy sample configs first so demoCount gets populated
  await copySampleConfigs(allElements);

  // Then generate registry with updated demoCount values
  await generateRegistry(allElements);

  console.log('[demo-metadata] âœ“ Demo metadata generation complete');
}
