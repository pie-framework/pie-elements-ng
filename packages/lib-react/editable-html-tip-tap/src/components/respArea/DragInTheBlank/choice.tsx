// @ts-nocheck
/**
 * @synced-from pie-lib/packages/editable-html-tip-tap/src/components/respArea/DragInTheBlank/choice.jsx
 * @synced-commit a933f8d7661c0d7d814f8732bd246cef24eeb040
 * @synced-date 2026-01-30
 * @sync-version v3
 * @auto-generated
 *
 * This file is automatically synced from pie-elements and converted to TypeScript.
 * Manual edits will be overwritten on next sync.
 * To make changes, edit the upstream JavaScript file and run sync again.
 */

import React, { useRef, useEffect, useState } from 'react';
import PropTypes from 'prop-types';
import { useDraggable, useDroppable } from '@dnd-kit/core';
import { color } from '@pie-lib/render-ui';
import { renderMath } from '@pie-element/shared-math-rendering-katex';
import { styled } from '@mui/material/styles';
import classnames from 'classnames';

import { GripIcon } from '../../icons/RespArea';

const StyledContent: any = styled('span')(({ theme }) => ({
  border: `solid 0px ${theme.palette.primary.main}`,
  '& mjx-frac': {
    fontSize: '120% !important',
  },
}));

export function BlankContent({ n, children, isDragging, isOver, dragItem, value }) {
  const [hoveredElementSize, setHoveredElementSize] = useState(null);
  const elementRef = useRef(null);

  const handleClick = (event) => {
    if (!elementRef.current) return;

    if (elementRef.current.contains(event.target)) {
      elementRef.current.classList.add('selected');
    } else {
      elementRef.current.classList.remove('selected');
    }
  };

  useEffect(() => {
    document.addEventListener('click', handleClick);
    return () => {
      document.removeEventListener('click', handleClick);
    };
  }, []);

  useEffect(() => {
    if (elementRef.current && typeof renderMath === 'function') {
      renderMath(elementRef.current);
    }
  }, [value?.value, isOver, dragItem?.value?.value]);

  useEffect(() => {
    if (isOver && elementRef.current && !hoveredElementSize) {
      const node = elementRef.current;
      setHoveredElementSize({ width: node.offsetWidth, height: node.offsetHeight });
    } else if (!isOver && hoveredElementSize) {
      setHoveredElementSize(null);
    }
  }, [isOver, hoveredElementSize]);

  const label = dragItem && isOver ? dragItem.value.value : value.value || '\u00A0';
  const finalLabel = isDragging ? '\u00A0' : label;
  const hasGrip = finalLabel !== '\u00A0';
  const isPreview = dragItem && isOver;

  return (
    <div
      ref={elementRef}
      style={{
        display: 'inline-flex',
        minWidth: '178px',
        minHeight: '36px',
        background: isPreview ? `${color.defaults.BORDER_LIGHT}` : `${color.defaults.WHITE}`,
        border: isPreview ? `1px solid  ${color.defaults.BORDER_DARK}` : `1px solid  ${color.defaults.BORDER_LIGHT}`,
        boxSizing: 'border-box',
        borderRadius: '3px',
        overflow: 'hidden',
        position: 'relative',
        padding: '8px 8px 8px 35px',
        width: hoveredElementSize ? hoveredElementSize.width : undefined,
        height: hoveredElementSize ? hoveredElementSize.height : undefined,
      }}
      data-key={n.index}
      contentEditable={false}
    >
      {hasGrip && (
        <GripIcon
          style={{
            position: 'absolute',
            top: '6px',
            left: '15px',
            color: '#9B9B9B',
          }}
          contentEditable={false}
        />
      )}
      <span
        dangerouslySetInnerHTML={{
          __html: finalLabel,
        }}
      />
      {children}
    </div>
  );
}

BlankContent.propTypes = {
  n: PropTypes.object,
  children: PropTypes.node,
  isDragging: PropTypes.bool,
  isOver: PropTypes.bool,
  dragItem: PropTypes.object,
  value: PropTypes.object,
};

function DragDropChoice({ value, disabled, instanceId, children, n, onChange, removeResponse, duplicates, pos }) {
  const { attributes: dragAttributes, listeners: dragListeners, setNodeRef: setDragNodeRef, isDragging } = useDraggable(
    {
      id: `drag-${n.index}`,
      disabled: disabled || !value?.value,
      data: {
        id: `drag-${n.index}`,
        value,
        instanceId,
        n,
        pos,
        opts: { duplicates },
        type: 'drag-in-the-blank-placed-choice',
        fromChoice: !value,
        onRemove: (draggedData) => removeResponse(draggedData),
        onDrop: (draggedData, dropData) => {
          // check if we're dropping into a blank
          const isValidBlank = dropData?.type === 'drag-in-the-blank-drop-choice';

          if (!isValidBlank) return;

          // place into blank
          onChange(draggedData);

          if (!duplicates && draggedData.fromChoice) {
            removeResponse(draggedData);
          }
        },
      },
    },
  );

  const { setNodeRef: setDropNodeRef, isOver, active: dragItem } = useDroppable({
    id: `drop-${n.index}`,
    data: {
      type: 'drag-in-the-blank-drop-choice',
      accepts: ['drag-in-the-blank-choice', 'drag-in-the-blank-placed-choice'],
      instanceId: instanceId,
      value: value,
      id: `drop-${n.index}`,
      pos,
      n,
      opts: { duplicates },
      onDrop: (draggedData, dropData) => {
        // check if we're dropping into a blank
        const isValidBlank = dropData?.type === 'drag-in-the-blank-drop-choice';

        if (!isValidBlank) return;

        // if the dragged and dropped data are the same, do nothing
        if (draggedData.value.id === dropData.value.id) return;

        if (draggedData.type === 'drag-in-the-blank-choice') {
          // place into blank
          onChange(draggedData);

          if (!duplicates && draggedData.fromChoice) {
            removeResponse(draggedData);
          }
          return;
        }

        // moving placed choice between blanks
        if (draggedData.type === 'drag-in-the-blank-placed-choice') {
          // clear target blank
          removeResponse(dropData);

          // set new blank value
          onChange(draggedData);

          // clear original blank - slight delay to ensure state updates correctly
          setTimeout(() => removeResponse(draggedData), 10);
        }
      },
    },
  });

  const setNodeRef = (node) => {
    setDragNodeRef(node);
    setDropNodeRef(node);
  };

  const dragContent = (
    <BlankContent n={n} isDragging={isDragging} isOver={isOver} dragItem={dragItem?.data?.current} value={value}>
      {children}
    </BlankContent>
  );

  const dragEl = !value ? (
    <span ref={setDropNodeRef}>{dragContent}</span>
  ) : (
    <span ref={setNodeRef} {...dragAttributes} {...dragListeners}>
      {dragContent}
    </span>
  );

  const content = <StyledContent className={classnames(isOver && 'over')}>{dragEl}</StyledContent>;

  return content;
}

DragDropChoice.propTypes = {
  value: PropTypes.object,
  disabled: PropTypes.bool,
  instanceId: PropTypes.string,
  children: PropTypes.node,
  n: PropTypes.object.isRequired,
  onChange: PropTypes.func.isRequired,
  removeResponse: PropTypes.func.isRequired,
  duplicates: PropTypes.bool,
};

export default DragDropChoice;
