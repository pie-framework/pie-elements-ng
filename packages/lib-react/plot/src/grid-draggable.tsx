// @ts-nocheck
/**
 * @synced-from pie-lib/packages/plot/src/grid-draggable.jsx
 * @auto-generated
 *
 * This file is automatically synced from pie-elements and converted to TypeScript.
 * Manual edits will be overwritten on next sync.
 * To make changes, edit the upstream JavaScript file and run sync again.
 */

import React from 'react';
import PropTypes from 'prop-types';
import { GraphPropsType } from './types.js';
import { DraggableCore } from './draggable.js';
import debug from 'debug';
import * as utils from './utils.js';
import { isFunction } from 'lodash-es';
import invariant from 'invariant';
import { pointer } from 'd3-selection';

const log = debug('pie-lib:plot:grid-draggable');

export const deltaFn = (scale, snap, val) => (delta) => {
  const normalized = delta + scale(0);
  const inverted = scale.invert(normalized);

  const fixDecimalsArithmetic = (snap(val + inverted).toFixed(4) * 1000) / 1000;

  return fixDecimalsArithmetic;
};

/**
 * Creates a Component that is draggable, within a bounded grid.
 * @param {*} opts
 */
export const gridDraggable = (opts) => (Comp) => {
  invariant(
    !!opts && isFunction(opts.fromDelta) && isFunction(opts.bounds) && isFunction(opts.anchorPoint),
    'You must supply an object with: { anchorPoint: Function, fromDelta: Function, bounds: Function }',
  );
  return class GridDraggable extends React.Component {
    static propTypes = {
      disabled: PropTypes.bool,
      onDragStart: PropTypes.func,
      onDrag: PropTypes.func,
      onDragStop: PropTypes.func,
      onClick: PropTypes.func,
      onMove: PropTypes.func,
      graphProps: GraphPropsType.isRequired,
    };

    constructor(props) {
      super(props);
      this.state = {
        startX: null,
        startY: null,
      };
    }

    grid: any = () => {
      const { graphProps } = this.props;
      const { scale, domain, range } = graphProps;
      return {
        x: scale.x(domain.step) - scale.x(0),
        y: scale.y(range.step) - scale.y(0),
      };
    };
    onStart: any = (e) => {
      const { onDragStart } = this.props;
      if (document.activeElement) {
        document.activeElement.blur();
      }
      this.setState({ startX: e.clientX, startY: e.clientY });
      if (onDragStart) {
        onDragStart();
      }
    };
    position: any = () => {
      const { x, y } = opts.anchorPoint(this.props);
      const { graphProps } = this.props;
      const { scale, snap } = graphProps;

      return {
        anchorPoint: {
          x,
          y,
        },
        x: deltaFn(scale.x, snap.x, x),
        y: deltaFn(scale.y, snap.y, y),
      };
    };

    tiny: any = (key, event) => {
      const K = key.toUpperCase();
      const end = event[`client${K}`];
      const start = this.state[`start${K}`];
      const delta = Math.abs(end - start);
      const out = delta < Math.abs(this.grid()[key]) / 10;
      log('[tiny] key: ', key, 'delta: ', delta, 'out: ', out);
      return out;
    };

    getScaledBounds: any = () => {
      const bounds = opts.bounds(this.props, this.props.graphProps);
      log('bounds: ', bounds);
      const grid = this.grid();

      let scaled = {
        left: bounds.left * grid.x,
        right: bounds.right * grid.x,
        top: bounds.top * grid.y,
        bottom: bounds.bottom * grid.y,
      };

      // Normalize Y bounds so that:
      // - top is <= 0 (negative or zero, allowing upward movement)
      // - bottom is >= 0 (positive or zero, allowing downward movement)
      // This compensates for the inverted Y scale (range.max -> 0, range.min -> size.height)
      // Add a small buffer (1 grid unit) to ensure we can reach exact boundaries
      const buffer = Math.abs(grid.y);
      scaled = {
        ...scaled,
        top: Math.min(0, scaled.top) - buffer, // More negative to allow reaching max
        bottom: Math.abs(scaled.bottom) + buffer, // More positive to allow reaching min
      };

      log('[getScaledBounds]: ', scaled);
      return scaled;
    };

    /**
     * Retrieves the coordinates of a mouse or touch event relative to an SVG element.
     * This method has been overwritten from the d3-selection library's clientPoint to handle touch events and improve clarity.
     * @param {Element} node - The SVG element.
     * @param {Event} event - The mouse or touch event.
     * @returns {Array} - An array containing the coordinates [x, y] relative to the SVG element.
     */
    getClientPoint: any = (node, event) => {
      if (!node || !event) {
        return null;
      }
      const svg = node.ownerSVGElement || node;

      if (svg && svg.createSVGPoint) {
        let point = svg.createSVGPoint();
        // Check if it's a touch event and use the first touch point
        if (event.touches && event.touches.length > 0) {
          const touch = event.touches[0];
          point.x = touch.clientX;
          point.y = touch.clientY;
        } else {
          // Fall back to mouse event properties
          point.x = event.clientX;
          point.y = event.clientY;
        }
        if (node.getScreenCTM) {
          point = point.matrixTransform(node.getScreenCTM().inverse());
          return [point.x, point.y];
        } else {
          return null;
        }
      }

      const rect = node.getBoundingClientRect();
      if (rect) {
        return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
      } else {
        return null;
      }
    };

    skipDragOutsideOfBounds: any = (dd, e, graphProps) => {
      // Ignore drag movement outside of the domain and range.
      const rootNode = graphProps.getRootNode();
      const clientPoint = this.getClientPoint(rootNode, e);

      if (clientPoint === null) {
        return true; // Indicate that the drag is outside of bounds
      }

      const [rawX, rawY] = clientPoint;
      const { scale, domain, range } = graphProps;
      let x = scale.x.invert(rawX);
      let y = scale.y.invert(rawY);

      const xOutside = (dd.deltaX > 0 && x < domain.min) || (dd.deltaX < 0 && x > domain.max);
      const yOutside = (dd.deltaY > 0 && y > range.max) || (dd.deltaY < 0 && y < range.min);
      return xOutside || yOutside;
    };

    onDrag: any = (e, dd) => {
      const { onDrag, graphProps } = this.props;

      if (!onDrag) {
        return;
      }

      const bounds = this.getScaledBounds();

      if (dd.deltaX < 0 && dd.deltaX < bounds.left) {
        return;
      }

      if (dd.deltaX > 0 && dd.deltaX > bounds.right) {
        return;
      }

      if (dd.deltaY < 0 && dd.deltaY < bounds.top) {
        return;
      }

      if (dd.deltaY > 0 && dd.deltaY > bounds.bottom) {
        return;
      }

      if (this.skipDragOutsideOfBounds(dd, e, graphProps)) {
        return;
      }

      const dragArg = this.applyDelta({ x: dd.deltaX, y: dd.deltaY });

      if (dragArg !== undefined || dragArg !== null) {
        onDrag(dragArg);
      }
    };

    getDelta: any = (point) => {
      const pos = this.position();

      const p = {
        x: pos.x(point.x),
        y: pos.y(point.y),
      };

      return utils.getDelta(pos.anchorPoint, p);
    };

    applyDelta: any = (point) => {
      const delta = this.getDelta(point);
      log('[applyDelta] delta:', delta);
      return opts.fromDelta(this.props, delta);
    };

    onStop: any = (e, dd) => {
      log('[onStop] dd:', dd);
      const { onDragStop, onClick } = this.props;

      if (onDragStop) {
        onDragStop();
      }

      log('[onStop] lastX/Y: ', dd.lastX, dd.lastY);
      const isClick = this.tiny('x', e) && this.tiny('y', e);

      if (isClick) {
        if (onClick) {
          log('call onClick');
          this.setState({ startX: null });
          const { graphProps } = this.props;
          const { scale, snap } = graphProps;
          const [rawX, rawY] = pointer(e, e.target);
          let x = scale.x.invert(rawX);
          let y = scale.y.invert(rawY);
          x = snap.x(x);
          y = snap.y(y);
          onClick({ x, y });
          return false;
        }
      }

      this.setState({ startX: null, startY: null });
      // return false to prevent state updates in the underlying draggable - a move will have triggered an update already.
      return false;
    };

    render() {
      const { disabled, ...rest } = this.props;
      const grid = this.grid();

      // prevent the text select icon from rendering.
      const onMouseDown = (e) => e.nativeEvent.preventDefault();

      /**
       * TODO: This shouldnt be necessary, we should be able to use the r-d classnames.
       * But they aren't being unset. If we continue with this lib, we'll have to fix this.
       */
      const isDragging = this.state ? !!this.state.startX : false;

      return (
        <DraggableCore
          disabled={disabled}
          onMouseDown={onMouseDown}
          onStart={this.onStart}
          onDrag={this.onDrag}
          onStop={this.onStop}
          axis={opts.axis || 'both'}
          grid={[grid.x, grid.y]}
        >
          <Comp {...rest} disabled={disabled} isDragging={isDragging} />
        </DraggableCore>
      );
    }
  };
};
