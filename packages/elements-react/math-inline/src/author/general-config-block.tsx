// @ts-nocheck
/**
 * @synced-from pie-elements/packages/math-inline/configure/src/general-config-block.jsx
 * @synced-commit 2a252291609481706fda098983c2973ccff27c81
 * @sync-version v3
 * @auto-generated
 *
 * This file is automatically synced from pie-elements and converted to TypeScript.
 * Manual edits will be overwritten on next sync.
 * To make changes, edit the upstream JavaScript file and run sync again.
 */

import * as React from 'react';
import PropTypes from 'prop-types';
import cx from 'classnames';
import EditableHtml from '@pie-lib/editable-html-tip-tap';
import { InputContainer } from '@pie-lib/config-ui';
import { styled } from '@mui/material/styles';
import InputLabel from '@mui/material/InputLabel';
import Select from '@mui/material/Select';
import MenuItem from '@mui/material/MenuItem';
import Response from './response';
import { MathToolbar } from '@pie-lib/math-toolbar';
import { isEqual } from 'lodash-es';
import { ResponseTypes, generateValidationMessage, getPluginProps } from './utils';
import MathQuill from '@pie-element/shared-mathquill';
import Info from '@mui/icons-material/Info';
import Tooltip from '@mui/material/Tooltip';

let registered = false;

// Helper function to get class names for HTML string generation
const getBlockClassNames = () => {
  // These will be generated by styled components, but we need them as strings for HTML
  // We'll use a simple approach: generate unique class names
  return {
    blockContainer: 'block-container',
    blockContainerGeneric: 'block-container-generic',
    blockResponse: 'block-response',
    blockResponseGeneric: 'block-response-generic',
  };
};

const Container: any = styled('div')({
  display: 'flex',
  flexDirection: 'column',
});

const TemplateTitle: any = styled(InputLabel)({
  fontSize: '0.85rem',
});

const Title: any = styled('div')({
  fontSize: '1.1rem',
});

const FlexContainer: any = styled('div')({
  display: 'flex',
  alignItems: 'center',
  justifyContent: 'space-between',
});

const SelectContainer: any = styled(InputContainer)(({ theme }) => ({
  flex: 'initial',
  width: '40%',
  marginTop: theme.spacing(2),
  marginBottom: theme.spacing(2),
  '& > *:not(label)': {
    marginTop: theme.spacing(1),
  },
}));

const ResponseTemplate: any = styled('div')({
  display: 'flex',
  flexDirection: 'column',
});

const StyledTooltip: any = styled(Tooltip)(({ theme }) => ({
  '& .MuiTooltip-tooltip': {
    fontSize: theme.typography.fontSize - 2,
    whiteSpace: 'pre-wrap',
  },
}));

const ErrorText: any = styled('div')(({ theme }) => ({
  fontSize: theme.typography.fontSize - 2,
  color: theme.palette.error.main,
  paddingTop: theme.spacing(1),
}));

const PromptHolder: any = styled(InputContainer)(({ theme }) => ({
  width: '100%',
  paddingTop: theme.spacing(2),
  marginBottom: theme.spacing(2),
}));

const AdvancedResponse: any = styled('div')(({ theme }) => ({
  marginBottom: theme.spacing(2.5),
}));

// CSS for block classes used in HTML string generation
// These need to be injected as global styles since they're used in dynamically generated HTML
if (typeof document !== 'undefined') {
  const styleId = 'math-inline-block-styles';
  if (!document.getElementById(styleId)) {
    const style = document.createElement('style');
    style.id = styleId;
    style.textContent = `
      .block-container {
        margin: 8px;
        display: inline-flex;
        border: 2px solid grey;
      }
      .block-container-generic {
        margin: 4px;
      }
      .block-response {
        flex: 2;
        color: grey;
        background: #f5f5f5;
        font-size: 0.8rem;
        padding: 4px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-right: 2px solid grey;
      }
      .block-response-generic {
        border-right: 0;
      }
      .response-editor {
        display: flex;
        justify-content: center;
        width: 100%;
        max-width: inherit;
        height: auto;
        min-height: 130px;
        text-align: left;
        padding: 8px;
      }
    `;
    document.head.appendChild(style);
  }
}

const REGEX = /{{response}}/gm;
const TEMPORARY_RESPONSE_FIELD = /\\%response\\%/gm;
const ANSWER_BLOCK_REGEX = /\\embed\{answerBlock\}\[r\d*\]/g;
const NEWLINE_BLOCK = /\\embed\{newLine\}\[\]/g;
const NEWLINE_LATEX = /\\newline/g;

function prepareForStatic(expression) {
  if (expression) {
    let answerBlocks = 1; // assume one at least

    return expression
      .replace(REGEX, () => `\\embed{answerBlock}[r${answerBlocks++}]`)
      .replace(NEWLINE_LATEX, '\\embed{newLine}[]');
  }
}

function prepareForModel(expression) {
  if (expression) {
    return expression
      .replace(ANSWER_BLOCK_REGEX, () => '{{response}}')
      .replace(TEMPORARY_RESPONSE_FIELD, () => '{{response}}')
      .replace(NEWLINE_BLOCK, () => '\\newline');
  }
}

class GeneralConfigBlock extends React.Component {
  static propTypes = {
    model: PropTypes.object.isRequired,
    imageSupport: PropTypes.object,
    uploadSoundSupport: PropTypes.object,
    configuration: PropTypes.object,
    onChange: PropTypes.func.isRequired,
    promptEnabled: PropTypes.bool,
    rationaleEnabled: PropTypes.bool,
    toolbarOpts: PropTypes.object,
  };

  constructor(props) {
    super(props);

    const responseAreas = {};

    if (props.model && props.model.expression) {
      let answerBlocks = 1; // assume one at least
      // build out local state model using responses declared in expression

      props.model.expression.replace(REGEX, () => {
        responseAreas[`r${answerBlocks++}`] = {
          value: '',
        };
      });
    }

    this.state = {
      showKeypad: false,
      responseAreas,
      responseIdCounter: Object.keys(responseAreas).length,
    };
  }

  onChange = (name) => (evtOrValue) => {
    const { model, onChange } = this.props;
    const newModel = { ...model };

    if (typeof evtOrValue === 'object') {
      newModel[name] = evtOrValue.target.value;
    } else {
      newModel[name] = evtOrValue;
    }

    if (name === 'expression') {
      newModel[name] = prepareForModel(evtOrValue);
    }

    onChange(newModel);
  };

  onDone: any = () => {
    this.setState({ showKeypad: false });
  };

  onFocus: any = () => {
    this.setState({ showKeypad: true });
  };

  onPromptFocus: any = () => {
    this.setState({ showKeypad: false });
  };

  UNSAFE_componentWillMount() {
    if (typeof window !== 'undefined') {
      // const MathQuill = require('@pie-framework/mathquill');
      let MQ = MathQuill.getInterface(2);

      if (!registered) {
        MQ.registerEmbed('answerBlock', (data) => {
          const classNames = getBlockClassNames();
          const genericAnswerBlock = `<div class="${cx(classNames.blockContainer, classNames.blockContainerGeneric)}">
                <div class="${cx(classNames.blockResponse, classNames.blockResponseGeneric)}" id="${data}Index">Response</div>
              </div>`;

          return {
            htmlString: genericAnswerBlock,
            text: () => 'text',
            latex: () => `\\embed{answerBlock}[${data}]`,
          };
        });

        registered = true;
      }
    }
  }

  componentDidMount() {
    this.handleAnswerBlockDomUpdate();
  }

  componentDidUpdate() {
    this.handleAnswerBlockDomUpdate();
  }

  handleAnswerBlockDomUpdate: any = () => {
    const { model } = this.props;

    const responseAreas = {};

    if (model && model.expression) {
      let answerBlocks = 1; // assume one at least
      // build out local state model using responses declared in expression

      model.expression.replace(REGEX, () => {
        responseAreas[`r${answerBlocks++}`] = {
          value: '',
        };
      });
    }

    if (!isEqual(responseAreas, this.state.responseAreas)) {
      this.setState(
        {
          responseAreas,
        },
        () => {
          if (this.root && Object.keys(responseAreas).length) {
            Object.keys(responseAreas).forEach((responseId, idx) => {
              const el = this.root.querySelector(`#${responseId}`);
              const indexEl = this.root.querySelector(`#${responseId}Index`);

              if (el) {
                // const MathQuill = require('@pie-framework/mathquill');
                let MQ = MathQuill.getInterface(2);
                // We no longer have individual answers, so we cannot set text content of blocks
                // el.textContent = response.answer;
                MQ.StaticMath(el);
                indexEl.textContent = `R${idx + 1}`;
              }
            });
          }
        },
      );
    }
  };

  onAddResponse: any = () => {
    const { model, onChange } = this.props;
    const { responseIdCounter } = this.state;
    const newModel = { ...model };

    let newCounter = responseIdCounter;

    while (model.responses.find((response) => response.id === newCounter)) {
      newCounter++;
    }

    const response = {
      id: newCounter,
      validation: 'literal',
      answer: '',
      alternates: {},
    };

    newModel.responses = newModel.responses.concat(response);
    onChange(newModel);

    this.setState({
      responseIdCounter: response.id,
    });
  };

  onResponseChange: any = (response, index) => {
    const { model, onChange } = this.props;
    const newModel = { ...model };

    newModel.responses[index] = response;
    onChange(newModel);
  };

  render() {
    const {
      model,
      imageSupport,
      uploadSoundSupport,
      configuration,
      promptEnabled,
      rationaleEnabled,
      toolbarOpts,
    } = this.props;
    const { showKeypad } = this.state;
    const {
      prompt,
      expression,
      equationEditor,
      promptEquationEditor = '8',
      responses,
      responseType,
      rationale,
      spellCheckEnabled,
      errors = {},
    } = model;
    const {
      baseInputConfiguration = {},
      rationale: cRationale = {},
      prompt: cPrompt = {},
      ignoreOrder: cIgnoreOrder = {},
      allowTrailingZeros: cAllowTrailingZeros = {},
      maxResponseAreas,
      maxImageWidth = {},
      maxImageHeight = {},
      mathMlOptions = {},
    } = configuration || {};
    const validationMessage = generateValidationMessage(configuration, model);
    const { prompt: promptError, rationale: rationaleError, responsesErrors, responseAreasError } = errors;

    const defaultImageMaxWidth = maxImageWidth && maxImageWidth.prompt;
    const defaultImageMaxHeight = maxImageHeight && maxImageHeight.prompt;

    const classNames = {
      editor: 'response-editor',
    };

    const responsesToUse = responseType === ResponseTypes.advanced ? responses : responses.slice(0, 1);

    const validationTooltip = (
      <StyledTooltip
        disableFocusListener
        disableTouchListener
        placement={'right'}
        title={validationMessage}
      >
        <Info fontSize={'small'} color={'primary'} style={{ marginLeft: '5px' }} />
      </StyledTooltip>
    );

    return (
      <Container ref={(r) => (this.root = r || this.root)}>
        {promptEnabled && (
          <PromptHolder label={cPrompt.label}>
            <EditableHtml
              onFocus={this.onPromptFocus}
              markup={prompt || ''}
              onChange={this.onChange('prompt')}
              imageSupport={imageSupport}
              nonEmpty={false}
              error={promptError}
              toolbarOpts={toolbarOpts}
              pluginProps={getPluginProps(cPrompt?.inputConfiguration, baseInputConfiguration)}
              spellCheck={spellCheckEnabled}
              maxImageWidth={defaultImageMaxWidth}
              maxImageHeight={defaultImageMaxHeight}
              uploadSoundSupport={uploadSoundSupport}
              languageCharactersProps={[{ language: 'spanish' }, { language: 'special' }]}
              mathMlOptions={mathMlOptions}
            />
            {promptError && <ErrorText>{promptError}</ErrorText>}
          </PromptHolder>
        )}

        {responseType === ResponseTypes.advanced && (
          <AdvancedResponse>
            <FlexContainer style={{ justifyContent: 'flex-start' }}>
              <Title>Define Response</Title>
              {validationTooltip}
            </FlexContainer>

            <SelectContainer
              key="templateEditorType"
              label="Response Template Equation Editor"
            >
              <Select
                onChange={this.onChange('promptEquationEditor')}
                value={promptEquationEditor}
                MenuProps={{transitionDuration: { enter: 225, exit: 195 } }}
              >
                <MenuItem value="non-negative-integers">Numeric - Non-Negative Integers</MenuItem>
                <MenuItem value="integers">Numeric - Integers</MenuItem>
                <MenuItem value="decimals">Numeric - Decimals</MenuItem>
                <MenuItem value="fractions">Numeric - Fractions</MenuItem>
                <MenuItem value={1}>Grade 1 - 2</MenuItem>
                <MenuItem value={3}>Grade 3 - 5</MenuItem>
                <MenuItem value={6}>Grade 6 - 7</MenuItem>
                <MenuItem value={8}>Grade 8 - HS</MenuItem>
                <MenuItem value={'geometry'}>Geometry</MenuItem>
                <MenuItem value={'advanced-algebra'}>Advanced Algebra</MenuItem>
                <MenuItem value={'statistics'}>Statistics</MenuItem>
                <MenuItem value={'item-authoring'}>Item Authoring</MenuItem>
              </Select>
            </SelectContainer>

            <ResponseTemplate key="templateHolder">
              <TemplateTitle>RESPONSE TEMPLATE</TemplateTitle>
              <MathToolbar
                classNames={classNames}
                allowAnswerBlock
                keypadMode={promptEquationEditor}
                controlledKeypad
                showKeypad={showKeypad}
                latex={prepareForStatic(expression) || ''}
                onChange={this.onChange('expression')}
                onFocus={this.onFocus}
                onDone={this.onDone}
                maxResponseAreas={maxResponseAreas}
                error={responseAreasError}
              />
            </ResponseTemplate>

            {responseAreasError && <ErrorText>{responseAreasError}</ErrorText>}
          </AdvancedResponse>
        )}

        <FlexContainer style={{ justifyContent: 'flex-start' }}>
          <Title>Define Correct Response</Title>
          {responseType === ResponseTypes.simple ? validationTooltip : null}
        </FlexContainer>

        <SelectContainer label="Equation Editor">
          <Select onChange={this.onChange('equationEditor')} value={equationEditor} MenuProps={{transitionDuration: { enter: 225, exit: 195 } }}>
            <MenuItem value="non-negative-integers">Numeric - Non-Negative Integers</MenuItem>
            <MenuItem value="integers">Numeric - Integers</MenuItem>
            <MenuItem value="decimals">Numeric - Decimals</MenuItem>
            <MenuItem value="fractions">Numeric - Fractions</MenuItem>
            <MenuItem value={1}>Grade 1 - 2</MenuItem>
            <MenuItem value={3}>Grade 3 - 5</MenuItem>
            <MenuItem value={6}>Grade 6 - 7</MenuItem>
            <MenuItem value={8}>Grade 8 - HS</MenuItem>
            <MenuItem value={'geometry'}>Geometry</MenuItem>
            <MenuItem value={'advanced-algebra'}>Advanced Algebra</MenuItem>
            <MenuItem value={'statistics'}>Statistics</MenuItem>
            <MenuItem value={'item-authoring'}>Item Authoring</MenuItem>
          </Select>
        </SelectContainer>

        {responsesToUse.map((response, idx) => (
          <Response
            key={response.id}
            mode={equationEditor}
            response={response}
            defaultResponse={responseType === ResponseTypes.simple}
            onResponseChange={this.onResponseChange}
            index={idx}
            cIgnoreOrder={cIgnoreOrder}
            cAllowTrailingZeros={cAllowTrailingZeros}
            error={responsesErrors && responsesErrors[idx]}
          />
        ))}

        {rationaleEnabled && (
          <PromptHolder label={cRationale.label}>
            <EditableHtml
              markup={rationale || ''}
              onChange={this.onChange('rationale')}
              imageSupport={imageSupport}
              nonEmpty={false}
              error={rationaleError}
              toolbarOpts={toolbarOpts}
              pluginProps={getPluginProps(cRationale?.inputConfiguration, {
                ...baseInputConfiguration,
                math: {
                  controlledKeypadMode: false,
                },
              })}
              spellCheck={spellCheckEnabled}
              maxImageWidth={(maxImageWidth && maxImageWidth.rationale) || defaultImageMaxWidth}
              maxImageHeight={(maxImageHeight && maxImageHeight.rationale) || defaultImageMaxHeight}
              uploadSoundSupport={uploadSoundSupport}
              languageCharactersProps={[{ language: 'spanish' }, { language: 'special' }]}
              mathMlOptions={mathMlOptions}
            />
            {rationaleError && <ErrorText>{rationaleError}</ErrorText>}
          </PromptHolder>
        )}
      </Container>
    );
  }
}

export default GeneralConfigBlock;
