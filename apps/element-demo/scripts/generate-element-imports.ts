#!/usr/bin/env bun
/**
 * Generate element-imports.ts
 *
 * This script automatically generates the element-imports.ts file based on
 * the element registry and available built elements.
 *
 * Run with: bun run scripts/generate-element-imports.ts
 */

import { resolve, dirname } from 'node:path';
import { existsSync, readFileSync, writeFileSync } from 'node:fs';
import { fileURLToPath } from 'node:url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Paths
const workspaceRoot = resolve(__dirname, '../../..');
const registryPath = resolve(__dirname, '../src/lib/elements/registry.ts');
const outputPath = resolve(__dirname, '../src/lib/element-imports.ts');

interface ElementMetadata {
  name: string;
  title: string;
  packageName: string;
  hasAuthor: boolean;
  hasPrint: boolean;
  hasConfig: boolean;
  hasSession: boolean;
}

/**
 * Load element registry
 */
function loadRegistry(): ElementMetadata[] {
  const content = readFileSync(registryPath, 'utf-8');

  // Extract the ELEMENT_REGISTRY array
  const match = content.match(/export const ELEMENT_REGISTRY[^=]*=\s*(\[[\s\S]*?\]);/);
  if (!match) {
    throw new Error('Could not find ELEMENT_REGISTRY in registry.ts');
  }

  const registryJson = match[1];
  return JSON.parse(registryJson);
}

/**
 * Check if an element has a built dist file
 */
function checkElementExists(elementName: string, subpath: string): boolean {
  const elementPath = resolve(
    workspaceRoot,
    'packages/elements-react',
    elementName,
    'dist',
    subpath
  );
  return existsSync(elementPath);
}

/**
 * Generate import registration for an element
 */
function generateElementImport(
  element: ElementMetadata,
  indent: string = ''
): string[] {
  const lines: string[] = [];
  const elementName = element.name;

  // Check which files exist
  const hasDelivery = checkElementExists(elementName, 'index.js');
  const hasController = checkElementExists(elementName, 'controller/index.js');
  const hasAuthor = element.hasAuthor && checkElementExists(elementName, 'author/index.js');
  const hasPrint = element.hasPrint && checkElementExists(elementName, 'print/index.js');

  if (!hasDelivery) {
    // Skip elements without a delivery component
    return [];
  }

  lines.push(`${indent}// Register element: ${elementName}`);

  // Delivery component
  lines.push(`${indent}registerElement('${elementName}', () =>`);
  lines.push(`${indent}  import(`);
  lines.push(`${indent}    /* @vite-ignore */`);
  lines.push(
    `${indent}    '/@fs${workspaceRoot}/packages/elements-react/${elementName}/dist/index.js'`
  );
  lines.push(`${indent}  )`);
  lines.push(`${indent});`);

  // Controller
  if (hasController) {
    lines.push(`${indent}registerController('${elementName}', () =>`);
    lines.push(`${indent}  import(`);
    lines.push(`${indent}    /* @vite-ignore */`);
    lines.push(
      `${indent}    '/@fs${workspaceRoot}/packages/elements-react/${elementName}/dist/controller/index.js'`
    );
    lines.push(`${indent}  )`);
    lines.push(`${indent});`);
  }

  // Author
  if (hasAuthor) {
    lines.push(`${indent}registerAuthor('${elementName}', () =>`);
    lines.push(`${indent}  import(`);
    lines.push(`${indent}    /* @vite-ignore */`);
    lines.push(
      `${indent}    '/@fs${workspaceRoot}/packages/elements-react/${elementName}/dist/author/index.js'`
    );
    lines.push(`${indent}  )`);
    lines.push(`${indent});`);
  }

  // Print
  if (hasPrint) {
    lines.push(`${indent}registerPrint('${elementName}', () =>`);
    lines.push(`${indent}  import(`);
    lines.push(`${indent}    /* @vite-ignore */`);
    lines.push(
      `${indent}    '/@fs${workspaceRoot}/packages/elements-react/${elementName}/dist/print/index.js'`
    );
    lines.push(`${indent}  )`);
    lines.push(`${indent});`);
  }

  return lines;
}

/**
 * Generate the complete element-imports.ts file
 */
function generateFile(elements: ElementMetadata[]): string {
  const lines: string[] = [];

  // Header
  lines.push('/**');
  lines.push(' * Element Static Imports');
  lines.push(' *');
  lines.push(
    ' * AUTO-GENERATED by scripts/generate-element-imports.ts - DO NOT EDIT MANUALLY'
  );
  lines.push(' *');
  lines.push(' * This file registers all available PIE elements with absolute paths.');
  lines.push(' * Using absolute /@fs/ paths bypasses package.json export conditions');
  lines.push(' * and ensures we load BUILT dist files for elements.');
  lines.push(' *');
  lines.push(' * IMPORTANT: We use absolute paths here instead of bare specifiers because:');
  lines.push(' * 1. Dynamic imports with variable paths (like in demo-element-loader.ts) don\'t');
  lines.push(' *    benefit from Vite\'s alias resolution');
  lines.push(' * 2. Absolute /@fs/ paths work correctly in dynamic imports');
  lines.push(' * 3. This ensures we load DIST files (fully built) instead of source files');
  lines.push(' *');
  lines.push(' * The workspace resolver plugin handles resolving dependencies that the');
  lines.push(
    ' * element dist files import (like @pie-element/shared-math-rendering-katex)'
  );
  lines.push(' *');
  lines.push(` * Generated: ${new Date().toISOString()}`);
  lines.push(' */');
  lines.push('');

  // Registry maps
  lines.push('// Element module registry');
  lines.push('const elementModules = new Map<string, () => Promise<any>>();');
  lines.push('const controllerModules = new Map<string, () => Promise<any>>();');
  lines.push('const authorModules = new Map<string, () => Promise<any>>();');
  lines.push('const printModules = new Map<string, () => Promise<any>>();');
  lines.push('');

  // Register helper functions
  lines.push('// Register helper functions');
  lines.push('export function registerElement(name: string, importer: () => Promise<any>) {');
  lines.push('  elementModules.set(name, importer);');
  lines.push('}');
  lines.push('');
  lines.push('export function registerController(name: string, importer: () => Promise<any>) {');
  lines.push('  controllerModules.set(name, importer);');
  lines.push('}');
  lines.push('');
  lines.push('export function registerAuthor(name: string, importer: () => Promise<any>) {');
  lines.push('  authorModules.set(name, importer);');
  lines.push('}');
  lines.push('');
  lines.push('export function registerPrint(name: string, importer: () => Promise<any>) {');
  lines.push('  printModules.set(name, importer);');
  lines.push('}');
  lines.push('');

  // Get helper functions
  lines.push('// Get helper functions');
  lines.push(
    'export function getElementModule(name: string): (() => Promise<any>) | undefined {'
  );
  lines.push('  return elementModules.get(name);');
  lines.push('}');
  lines.push('');
  lines.push(
    'export function getControllerModule(name: string): (() => Promise<any>) | undefined {'
  );
  lines.push('  return controllerModules.get(name);');
  lines.push('}');
  lines.push('');
  lines.push(
    'export function getAuthorModule(name: string): (() => Promise<any>) | undefined {'
  );
  lines.push('  return authorModules.get(name);');
  lines.push('}');
  lines.push('');
  lines.push(
    'export function getPrintModule(name: string): (() => Promise<any>) | undefined {'
  );
  lines.push('  return printModules.get(name);');
  lines.push('}');
  lines.push('');
  lines.push('export function hasElementModule(name: string): boolean {');
  lines.push('  return elementModules.has(name);');
  lines.push('}');
  lines.push('');

  // Element registrations
  lines.push('// ============================================================================');
  lines.push('// ELEMENT REGISTRATIONS');
  lines.push('// ============================================================================');
  lines.push('');

  // Generate imports for each element
  for (const element of elements) {
    const elementLines = generateElementImport(element);
    if (elementLines.length > 0) {
      lines.push(...elementLines);
      lines.push('');
    }
  }

  return lines.join('\n');
}

/**
 * Main
 */
function main() {
  console.log('ğŸ” Loading element registry...');
  const elements = loadRegistry();
  console.log(`   Found ${elements.length} elements in registry`);

  console.log('ğŸ“ Generating element-imports.ts...');
  const content = generateFile(elements);

  console.log(`ğŸ’¾ Writing to ${outputPath}`);
  writeFileSync(outputPath, content, 'utf-8');

  console.log('âœ… Done!');
  console.log('');
  console.log('ğŸ’¡ The element-imports.ts file has been regenerated.');
  console.log('   Restart the dev server if it\'s running to pick up changes.');
}

main();
